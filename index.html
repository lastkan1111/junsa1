<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>가로형 RPG - 자동사냥 + 토끼 전투 (v3)</title>
<style>
  html,body{margin:0;padding:0;width:100%;height:100%;background:#000;overflow:hidden;touch-action:none;}
  canvas{display:block;width:100vw;height:100vh;image-rendering:pixelated;image-rendering:crisp-edges;}

  /* === TITLE OVERLAY === */
  .titleOverlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,0.92);
    display:flex; align-items:center; justify-content:center;
    z-index:9999;
  }
  .titleCard{
    width:min(520px, 92vw);
    display:flex; flex-direction:column; align-items:center; gap:18px;
    padding:24px 18px;
  }
  .gameTitle{
    color:#fff;
    font:800 clamp(34px, 6vw, 56px)/1.05 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    letter-spacing:-0.02em;
    text-shadow:0 6px 24px rgba(0,0,0,.55);
  }
  .startBtn{
    appearance:none; border:none; cursor:pointer;
    padding:14px 22px;
    width:min(320px, 78vw);
    border-radius:16px;
    color:#fff;
    font:700 18px/1 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    background:rgba(255,255,255,0.08);
    outline:2px solid rgba(255,255,255,0.16);
    box-shadow:0 10px 30px rgba(0,0,0,.35);
    transition:transform .08s ease, outline-color .12s ease, background .12s ease;
  }
  .startBtn:hover{
    background:rgba(255,255,255,0.12);
    outline-color:rgba(255,255,255,0.28);
  }
  .startBtn:active{ transform:translateY(1px) scale(0.99); }
  .startBtn:focus-visible{
    outline-color:rgba(120,220,255,0.75);
    box-shadow:0 0 0 4px rgba(120,220,255,0.25), 0 10px 30px rgba(0,0,0,.35);
  }
  .hint{
    color:rgba(255,255,255,0.65);
    font:500 13px/1.35 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    text-align:center;
  }

  .ui{
    position:fixed;left:12px;top:10px;color:#eee;font:14px system-ui,sans-serif;
    background:rgba(0,0,0,.45);padding:8px 10px;border-radius:10px;user-select:none;
  }

  /* === TWITCH CHAT (bottom-left, always translucent, resizable) === */
  .twitchChatWrap{
    position:fixed;
    left:12px;
    bottom:12px;
    width:360px;
    height:260px;
    min-width:240px;
    min-height:160px;
    max-width:min(92vw, 560px);
    max-height:min(60vh, 520px);
    z-index:9000;
    border-radius:14px;
    overflow:hidden;
    background:rgba(0,0,0,0.18);
    backdrop-filter: blur(7px);
    -webkit-backdrop-filter: blur(7px);
    outline:1px solid rgba(255,255,255,0.12);
    box-shadow:0 12px 30px rgba(0,0,0,0.38);
    pointer-events:auto;
    resize: both; /* ✅ 자유 크기 조절 */
  }
  .twitchChatHeader{
    height:30px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:0 10px;
    color:rgba(255,255,255,0.92);
    font:700 12px/1 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    background:rgba(0,0,0,0.22);
    user-select:none;
  }
  .twitchChatHeader .left{
    display:flex; align-items:center; gap:8px;
    min-width:0;
  }
  .twitchChatHeader .dot{
    width:6px;height:6px;border-radius:50%;
    background:#a970ff;
    box-shadow:0 0 0 2px rgba(169,112,255,0.22);
    flex:0 0 auto;
  }
  .twitchChatHeader .title{
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .twitchChatBody{
    height:calc(100% - 30px);
    padding:8px 10px 10px;
    overflow:auto;
    color:rgba(255,255,255,0.92);
    font:600 12.5px/1.35 system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.22) rgba(255,255,255,0.06);
  }
  .twitchChatBody::-webkit-scrollbar{ width:10px; }
  .twitchChatBody::-webkit-scrollbar-thumb{
    background:rgba(255,255,255,0.18);
    border-radius:10px;
    border:2px solid rgba(0,0,0,0.0);
    background-clip: padding-box;
  }
  .twitchChatBody::-webkit-scrollbar-track{ background:rgba(255,255,255,0.06); }

  .chatLine{ margin:0 0 6px; }
  .chatName{ color:rgba(169,112,255,1); }
  .chatMsg{ color:rgba(255,255,255,0.92); word-break:break-word; }

  /* 리사이즈 핸들 시인성 */
  .twitchChatWrap::after{
    content:"";
    position:absolute;
    right:6px; bottom:6px;
    width:14px; height:14px;
    border-right:2px solid rgba(255,255,255,0.22);
    border-bottom:2px solid rgba(255,255,255,0.22);
    border-bottom-right-radius:4px;
    pointer-events:none;
  }

  @media (max-width: 520px){
    .twitchChatWrap{
      width:min(320px, 92vw);
      height:clamp(160px, 26vh, 280px);
      left:10px;
      bottom:10px;
      max-height:min(52vh, 420px);
    }
  }
</style>
</head>
<body>

  <!-- ✅ 시작 오버레이 -->
  <div id="titleOverlay" class="titleOverlay">
    <div class="titleCard">
      <div class="gameTitle">RPG Demo</div>
      <div id="startHint" class="hint">리소스 로딩 중...</div>
      <button id="startBtn" class="startBtn" disabled>Start</button>
      <div class="hint">모바일: 화면 터치 / PC: WASD 이동, 클릭 공격</div>
    </div>
  </div>

  <canvas id="game"></canvas>

  <!-- ✅ 트위치 채팅창 (좌측 하단 고정 / 항상 연한 검은 불투명 / 크기 조절 가능) -->
  <div id="twitchChatWrap" class="twitchChatWrap" aria-label="twitch chat">
    <div class="twitchChatHeader">
      <div class="left"><span class="dot"></span><span id="twitchChatTitle" class="title">Twitch Chat</span></div>
      <span id="twitchChatStatus" style="font-weight:700;color:rgba(255,255,255,0.7)"></span>
    </div>
    <div id="twitchChatBody" class="twitchChatBody"></div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const overlay = document.getElementById('titleOverlay');
  const startBtn = document.getElementById('startBtn');
  const startHint = document.getElementById('startHint');

  let started = false;
  let assetsReady = false;

  // roundRect 폴리필(구형 브라우저 대비)
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.imageSmoothingEnabled = false;
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ====== ASSETS ======
  const heroImg = new Image(); heroImg.src = 'hero.png';
  const grassImg = new Image(); grassImg.src = 'grass.png';
  const rabbitImg = new Image(); rabbitImg.src = 'rabbit.png';
  const treeImg = new Image(); treeImg.src = 'tree.png';

  let loaded = 0;
  const NEED = 4;
  function onLoaded(){
    loaded++;
    if (loaded >= NEED){
      assetsReady = true;
      startBtn.disabled = false;
      startHint.textContent = "Start를 누르면 바로 시작됩니다.";
    }
  }
  heroImg.onload = onLoaded; grassImg.onload = onLoaded; rabbitImg.onload = onLoaded; treeImg.onload = onLoaded;

  function onAssetError(name){
    return () => alert(name + " 파일을 찾을 수 없습니다. 이 html과 같은 폴더에 두고 파일명을 정확히 맞춰주세요.");
  }
  heroImg.onerror = onAssetError('hero.png');
  grassImg.onerror = onAssetError('grass.png');
  rabbitImg.onerror = onAssetError('rabbit.png');
  treeImg.onerror = onAssetError('tree.png');

  // ====== UTILS ======
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const dist2 = (ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by;return dx*dx+dy*dy;};

  // ====== TREES (맵 바깥 장식용) ======
  const TREES_N = 30;
  const trees = [];
  const TREE_SIZE = 96;
  const OUT_MARGIN = 120;

  function resolveCircle(a,b,minDist){
    const dx = b.x-a.x, dy = b.y-a.y;
    const d = Math.hypot(dx,dy);
    if (d === 0 || d >= minDist) return false;
    const nx = dx/d, ny = dy/d;
    const push = (minDist - d)/2;
    a.x -= nx*push; a.y -= ny*push;
    b.x += nx*push; b.y += ny*push;
    return true;
  }

  function vecToDir(vx,vy){
    if (Math.abs(vx) > Math.abs(vy)) return vx>0 ? DIR.RIGHT : DIR.LEFT;
    return vy>0 ? DIR.DOWN : DIR.UP;
  }

  function drawHpBar(screenX, screenY, w, h, ratio, fill){
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(screenX, screenY, w, h);
    ctx.fillStyle = fill;
    ctx.fillRect(screenX, screenY, Math.max(0, Math.min(1, ratio))*w, h);
  }

  // ====== MAP ======
  const MAP_W = 700, MAP_H = 700;
  const TILE = 64;

  // ====== SPRITE ======
  const HERO_FW = 50, HERO_FH = 50;
  const WALK_START = 0, WALK_LEN = 4;
  const ATK_START  = 4, ATK_LEN  = 4;
  const DIR = { DOWN:0, LEFT:1, RIGHT:2, UP:3 };

  // ====== RABBITS ======
  const RABBITS_N = 10;
  const rabbits = [];

  const R = {
    cols: 4, rows: 4,
    fw: 0, fh: 0,
    speedWander: 0.4,
    speedChase:  0.7,
    detectRadius: 130,
    giveUpRadius: 170,
    wanderChangeMin: 0.7,
    wanderChangeMax: 1.8,
    animFPS: 8,
    r: 14,
    hpMax: 10,
    dmg: 1,
    atkInterval: 0.9,
    fadeSpeed: 1.8,
    respawnDelay: 10
  };

  function pickWander(rb){
    const a = Math.random()*Math.PI*2;
    rb.vx = Math.cos(a);
    rb.vy = Math.sin(a);
    rb.tWander = rand(R.wanderChangeMin, R.wanderChangeMax);
  }

  function newRabbit(){
    const rb = {
      x: rand(20, MAP_W-20),
      y: rand(20, MAP_H-20),
      vx: 0, vy: 0,
      dir: DIR.DOWN,
      frame: Math.floor(Math.random()*4),
      tAnim: 0,
      state: 'wander',
      tWander: rand(R.wanderChangeMin, R.wanderChangeMax),
      hpMax: R.hpMax,
      hp: R.hpMax,
      atkCooldown: rand(0, R.atkInterval),
      alpha: 1,
      respawnT: 0
    };
    pickWander(rb);
    return rb;
  }

  function spawnRabbits(){
    rabbits.length = 0;
    for (let i=0;i<RABBITS_N;i++) rabbits.push(newRabbit());
  }

  function rabbitRespawn(rb){
    rb.x = rand(20, MAP_W-20);
    rb.y = rand(20, MAP_H-20);
    rb.hp = rb.hpMax;
    rb.alpha = 1;
    rb.state = 'wander';
    rb.atkCooldown = rand(0, R.atkInterval);
    pickWander(rb);
  }

  // ====== PLAYER ======
  const player = {
    x: MAP_W/2, y: MAP_H/2,
    r: 16,
    dir: DIR.DOWN,
    walkFrame: 0,
    atkFrame: 0,
    animT: 0,
    attacking: false,
    hpMax: 50,
    hp: 50,
    speed: R.speedChase,
    alpha: 1,
    state: 'alive',
    respawnT: 0,
    respawnDelay: 2,

    atkCooldown: 0,
    atkInterval: 0.55,
    dmg: 2,
    auto: true,
    autoDelay: 0,
    autoDelayTime: 1.0,
  };

  // ====== INPUT ======
  const keys = Object.create(null);
  let manualMove = false;

  addEventListener('keydown', (e) => {
    if (!started) return;
    keys[e.key] = true;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'].includes(e.key)) manualMove = true;
    if (e.key === ' ') { e.preventDefault(); tryPlayerAttack(); }
  }, {passive:false});
  addEventListener('keyup', (e) => {
    if (!started) return;
    keys[e.key] = false;
    manualMove = (keys['ArrowUp']||keys['ArrowDown']||keys['ArrowLeft']||keys['ArrowRight']||
                  keys['w']||keys['a']||keys['s']||keys['d']||keys['W']||keys['A']||keys['S']||keys['D']) || false;
  }, {passive:true});
  addEventListener('touchstart', () => { if (started) tryPlayerAttack(); }, {passive:true});
  addEventListener('mousedown', () => { if (started) tryPlayerAttack(); }, {passive:true});

  // ====== CAMERA ======
  function camera(){
    const vw = innerWidth, vh = innerHeight;
    let camX = player.x - vw/2, camY = player.y - vh/2;
    camX = (MAP_W <= vw) ? (MAP_W - vw)/2 : Math.max(0, Math.min(MAP_W - vw, camX));
    camY = (MAP_H <= vh) ? (MAP_H - vh)/2 : Math.max(0, Math.min(MAP_H - vh, camY));
    return {camX, camY, vw, vh};
  }

  // ====== PARTICLES (피 튐) ======
  const particles = [];
  function spawnBlood(px, py){
    for (let i=0;i<14;i++){
      const a = Math.random()*Math.PI*2;
      const sp = rand(40, 130);
      particles.push({
        x: px, y: py,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        life: rand(0.25, 0.55),
        t: 0,
        r: rand(1.5, 3.2)
      });
    }
  }
  function updateParticles(dt){
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      p.vy += 220*dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      if (p.t >= p.life) particles.splice(i,1);
    }
  }
  function drawParticles(camX, camY){
    ctx.save();
    for (const p of particles){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = Math.max(0, a);
      ctx.fillStyle = "rgba(255,70,70,1)";
      ctx.beginPath();
      ctx.arc(p.x - camX, p.y - camY, p.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  // ====== COMBAT HELPERS ======
  function nearestAliveRabbit(){
    let best = null;
    let bestD = Infinity;
    for (const rb of rabbits){
      if (rb.state === 'dead' || rb.state === 'respawn') continue;
      if (rb.hp <= 0) continue;
      const d = dist2(player.x, player.y, rb.x, rb.y);
      if (d < bestD){ bestD = d; best = rb; }
    }
    return best;
  }

  const CONTACT = player.r + R.r + 1;
  const CONTACT2 = CONTACT * CONTACT;

  function tryPlayerAttack(){
    if (player.state !== 'alive') return;
    if (player.atkCooldown > 0) return;

    for (const rb of rabbits){
      if (rb.hp <= 0 || rb.state === 'dead' || rb.state === 'respawn') continue;
      const d = dist2(player.x, player.y, rb.x, rb.y);
      if (d <= CONTACT2){
        player.attacking = true;
        player.atkFrame = 0;
        player.animT = 0;
        player.atkCooldown = player.atkInterval;

        rb.hp -= player.dmg;
        spawnBlood(rb.x, rb.y);

        if (rb.hp <= 0){
          rb.hp = 0;
          rb.state = 'dead';
        } else {
          rb.state = 'attack';
        }
        return;
      }
    }
  }

  function rabbitAttack(rb){
    if (player.state !== 'alive') return;
    if (rb.atkCooldown > 0) return;
    rb.atkCooldown = R.atkInterval;
    player.hp = Math.max(0, player.hp - R.dmg);
    spawnBlood(player.x, player.y - 6);

    if (player.hp <= 0){
      player.hp = 0;
      player.state = 'dead';
    }
  }

  // ====== UPDATE ======
  function updatePlayer(dt){
    if (player.state === 'dead'){
      player.alpha = Math.max(0, player.alpha - R.fadeSpeed * dt);
      if (player.alpha <= 0){
        player.state = 'respawn';
        player.respawnT = player.respawnDelay;
      }
      return;
    }
    if (player.state === 'respawn'){
      player.respawnT -= dt;

      if (player.respawnT <= 0){
        player.state = 'alive';
        player.alpha = 1;
        player.hp = player.hpMax;
        player.x = MAP_W/2;
        player.y = MAP_H/2;

        player.dir = DIR.DOWN;
        player.attacking = false;
        player.atkCooldown = 0;

        player.auto = false;
        player.autoDelay = player.autoDelayTime;
      }
      return;
    }

    player.atkCooldown = Math.max(0, player.atkCooldown - dt);

    let mvx = 0, mvy = 0;
    let moving = false;

    if (manualMove){
      if (keys['ArrowUp'] || keys['w'] || keys['W'])    { mvy -= 1; moving = true; }
      if (keys['ArrowDown'] || keys['s'] || keys['S']) { mvy += 1; moving = true; }
      if (keys['ArrowLeft'] || keys['a'] || keys['A']) { mvx -= 1; moving = true; }
      if (keys['ArrowRight'] || keys['d'] || keys['D']){ mvx += 1; moving = true; }
      const len = Math.hypot(mvx,mvy) || 1;
      mvx /= len; mvy /= len;
      if (moving) player.dir = vecToDir(mvx,mvy);
    } else if (player.auto){
      const target = nearestAliveRabbit();
      if (target){
        const dx = target.x - player.x, dy = target.y - player.y;
        const d = Math.hypot(dx,dy) || 1;
        const nx = dx/d, ny = dy/d;

        if (d*d <= CONTACT2 * 1.05){
          mvx = 0; mvy = 0;
          moving = false;
          tryPlayerAttack();
        } else {
          mvx = nx; mvy = ny;
          moving = true;
          player.dir = vecToDir(mvx,mvy);
        }
      }
    }

    const spd = player.attacking ? player.speed * 0.35 : player.speed;
    player.x += mvx * spd;
    player.y += mvy * spd;

    player.x = clamp(player.x, player.r, MAP_W - player.r);
    player.y = clamp(player.y, player.r, MAP_H - player.r);

    player.animT += dt;

    if (player.attacking){
      if (player.animT >= 1/14){
        player.animT = 0;
        player.atkFrame++;
        if (player.atkFrame >= ATK_LEN){
          player.attacking = false;
          player.atkFrame = 0;
        }
      }
    } else if (moving){
      if (player.animT >= 1/10){
        player.animT = 0;
        player.walkFrame = (player.walkFrame + 1) % WALK_LEN;
      }
    } else {
      player.walkFrame = 0;
    }
  }

  function animateRabbitWalk(rb, dt){
    rb.tAnim += dt;
    if (rb.tAnim >= 1/R.animFPS){
      rb.tAnim = 0;
      rb.frame = (rb.frame + 1) % 4;
    }
  }

  function updateRabbits(dt){
    const d2 = R.detectRadius*R.detectRadius;
    const g2 = R.giveUpRadius*R.giveUpRadius;

    for (const rb of rabbits){
      if (rb.state === 'respawn'){
        rb.respawnT -= dt;
        if (rb.respawnT <= 0) rabbitRespawn(rb);
        continue;
      }

      if (rb.state === 'dead'){
        rb.alpha = Math.max(0, rb.alpha - R.fadeSpeed * dt);
        if (rb.alpha <= 0){
          rb.state = 'respawn';
          rb.respawnT = R.respawnDelay;
        }
        continue;
      }

      rb.atkCooldown = Math.max(0, rb.atkCooldown - dt);

      const dd = dist2(rb.x, rb.y, player.x, player.y);
      const touching = dd <= CONTACT2;

      if (touching){
        rb.state = 'attack';
        rb.vx = 0; rb.vy = 0;
        rb.dir = vecToDir(player.x - rb.x, player.y - rb.y);
        animateRabbitWalk(rb, dt);
        rabbitAttack(rb);
      } else {
        if (rb.state === 'wander' && dd <= d2) rb.state = 'chase';
        if (rb.state === 'chase' && dd >= g2) { rb.state = 'wander'; pickWander(rb); }

        let mvx=0, mvy=0, spd=0;

        if (rb.state === 'chase'){
          const dx = player.x - rb.x, dy = player.y - rb.y;
          const len = Math.hypot(dx,dy) || 1;
          mvx = dx/len; mvy = dy/len; spd = R.speedChase;
        } else {
          rb.tWander -= dt;
          if (rb.tWander <= 0) pickWander(rb);
          mvx = rb.vx; mvy = rb.vy; spd = R.speedWander;
        }

        rb.x += mvx*spd;
        rb.y += mvy*spd;

        rb.x = clamp(rb.x, R.r, MAP_W-R.r);
        rb.y = clamp(rb.y, R.r, MAP_H-R.r);

        const moving = (Math.abs(mvx)+Math.abs(mvy))>0.01;
        if (moving) rb.dir = vecToDir(mvx,mvy);

        if (moving) animateRabbitWalk(rb, dt);
        else rb.frame = 0;
      }
    }

    // 토끼끼리 분리
    for (let i=0;i<rabbits.length;i++){
      const a = rabbits[i];
      if (a.state === 'dead' || a.state === 'respawn') continue;
      for (let j=i+1;j<rabbits.length;j++){
        const b = rabbits[j];
        if (b.state === 'dead' || b.state === 'respawn') continue;
        resolveCircle(a,b,R.r*2);
        a.x = clamp(a.x, R.r, MAP_W-R.r); a.y = clamp(a.y, R.r, MAP_W-R.r);
        b.x = clamp(b.x, R.r, MAP_W-R.r); b.y = clamp(b.y, R.r, MAP_W-R.r);
      }
    }

    // 플레이어-토끼 분리
    for (const rb of rabbits){
      if (rb.state === 'dead' || rb.state === 'respawn') continue;
      resolveCircle(player, rb, player.r + R.r);
      player.x = clamp(player.x, player.r, MAP_W-player.r);
      player.y = clamp(player.y, player.r, MAP_H-player.r);
      rb.x = clamp(rb.x, R.r, MAP_W-R.r);
      rb.y = clamp(rb.y, R.r, MAP_H-R.r);
    }
  }

  // ====== DRAW ======
  function drawGrass(camX, camY, vw, vh){
    const startTX = Math.floor(camX / TILE);
    const startTY = Math.floor(camY / TILE);
    const endTX = Math.ceil((camX + vw) / TILE);
    const endTY = Math.ceil((camY + vh) / TILE);

    for (let ty = startTY; ty < endTY; ty++){
      for (let tx = startTX; tx < endTX; tx++){
        const wx = tx*TILE, wy = ty*TILE;
        ctx.drawImage(grassImg, 0, 0, grassImg.width, grassImg.height,
                      wx - camX, wy - camY, TILE, TILE);
      }
    }
  }

  function drawRabbit(rb, camX, camY){
    if (!(rabbitImg.complete && rabbitImg.naturalWidth>0)) return;

    const col = rb.frame;
    const row = rb.dir;
    const sx = rb.x - camX - R.fw/2;
    const sy = rb.y - camY - R.fh/2;

    ctx.save();
    ctx.globalAlpha = rb.alpha;

    ctx.drawImage(rabbitImg, col*R.fw, row*R.fh, R.fw, R.fh,
                  Math.round(sx), Math.round(sy), R.fw, R.fh);

    if (rb.state !== 'respawn' && rb.alpha > 0){
      const bw = 22, bh = 4;
      const bx = (rb.x - camX) - bw/2;
      const by = (rb.y - camY) - R.fh/2 - bh + 13; // ✅ 머리 바로 위
      drawHpBar(bx, by, bw, bh, rb.hp/rb.hpMax, "rgba(255,120,120,1)");
    }

    ctx.restore();
  }

  function drawPlayer(camX, camY){
    if (!(heroImg.complete && heroImg.naturalWidth>0)) return;

    const col = player.attacking ? (ATK_START + player.atkFrame) : (WALK_START + player.walkFrame);
    const sx = player.x - camX - HERO_FW/2;
    const sy = player.y - camY - HERO_FH/2;

    ctx.save();
    ctx.globalAlpha = player.alpha;

    ctx.drawImage(heroImg, col*HERO_FW, player.dir*HERO_FH, HERO_FW, HERO_FH,
                  Math.round(sx), Math.round(sy), HERO_FW, HERO_FH);

    if (player.state !== 'respawn' && player.alpha > 0){
      const bw = 28, bh = 5;
      const bx = (player.x - camX) - bw/2;
      const by = (player.y - camY) - HERO_FH/2 - bh - 1; // ✅ 머리 딱 붙게
      drawHpBar(bx, by, bw, bh, player.hp/player.hpMax, "rgba(150,255,150,1)");
    }

    ctx.restore();
  }

  function drawTrees(camX, camY){
    if (!(treeImg.complete && treeImg.naturalWidth > 0)) return;
    for (const t of trees){
      ctx.drawImage(
        treeImg,
        t.x - camX - TREE_SIZE/2,
        t.y - camY - TREE_SIZE,
        TREE_SIZE,
        TREE_SIZE
      );
    }
  }

  function spawnTrees(){
    trees.length = 0;

    const MIN_TREE_DIST = TREE_SIZE * 0.75;
    const MAX_TRIES_PER_TREE = 80;

    function pickPosOutside(){
      let x, y;
      const side = Math.floor(Math.random()*4);

      if (side === 0) { // 위
        x = rand(-OUT_MARGIN, MAP_W + OUT_MARGIN);
        y = rand(-OUT_MARGIN, -20);
      } else if (side === 1) { // 아래
        x = rand(-OUT_MARGIN, MAP_W + OUT_MARGIN);
        y = rand(MAP_H + 20, MAP_H + OUT_MARGIN);
      } else if (side === 2) { // 왼쪽
        x = rand(-OUT_MARGIN, -20);
        y = rand(-OUT_MARGIN, MAP_H + OUT_MARGIN);
      } else { // 오른쪽
        x = rand(MAP_W + 20, MAP_W + OUT_MARGIN);
        y = rand(-OUT_MARGIN, MAP_H + OUT_MARGIN);
      }
      return {x, y};
    }

    function isFarEnough(x, y){
      for (const t of trees){
        const dx = x - t.x, dy = y - t.y;
        if (dx*dx + dy*dy < MIN_TREE_DIST*MIN_TREE_DIST) return false;
      }
      return true;
    }

    for (let i=0;i<TREES_N;i++){
      let placed = false;
      for (let tries=0; tries<MAX_TRIES_PER_TREE; tries++){
        const p = pickPosOutside();
        if (isFarEnough(p.x, p.y)){
          trees.push(p);
          placed = true;
          break;
        }
      }
      if (!placed) trees.push(pickPosOutside());
    }
  }

  // ====== LOOP ======
  let last = performance.now();

  function startGame(){
    if (started) return;
    started = true;

    R.fw = Math.floor(rabbitImg.naturalWidth / R.cols);
    R.fh = Math.floor(rabbitImg.naturalHeight / R.rows);
    spawnRabbits();
    spawnTrees();

    last = performance.now();
    requestAnimationFrame(loop);
  }

  function loop(t){
    const dt = Math.min(0.05, (t-last)/1000);
    last = t;

    updatePlayer(dt);

    if (player.autoDelay > 0){
      player.autoDelay -= dt;
      if (player.autoDelay <= 0){
        player.auto = true;
      }
    }

    updateRabbits(dt);
    updateParticles(dt);

    draw();
    requestAnimationFrame(loop);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const {camX, camY, vw, vh} = camera();

    drawGrass(camX, camY, vw, vh);

    // 맵 테두리
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#7CFC00";
    const radius = 24;
    ctx.roundRect(-camX, -camY, MAP_W, MAP_H, radius);
    ctx.stroke();
    ctx.restore();

    const drawList = [];
    for (const rb of rabbits) drawList.push({y: rb.y, type:'rb', ref: rb});
    drawList.push({y: player.y, type:'pl', ref: player});
    drawList.sort((a,b)=>a.y-b.y);

    for (const it of drawList){
      if (it.type === 'rb') drawRabbit(it.ref, camX, camY);
      else drawPlayer(camX, camY);
    }

    drawParticles(camX, camY);
    drawTrees(camX, camY);
  }

  // ====== START BUTTON: overlay hide + fullscreen + game start ======
  async function goFullscreen(){
    try{
      if (!document.fullscreenElement){
        await document.documentElement.requestFullscreen({ navigationUI: "hide" }).catch(()=>{});
      }
    }catch(e){}
  }

  startBtn.disabled = true;
  startHint.textContent = "리소스 로딩 중... (hero/grass/rabbit/tree)";

  startBtn.addEventListener('click', async () => {
    await goFullscreen();
    setTimeout(resize, 50);
    setTimeout(resize, 250);

    overlay.style.display = "none";

    if (assetsReady){
      startGame();
    } else {
      startHint.textContent = "로딩이 끝나면 자동으로 시작됩니다...";
      const wait = setInterval(() => {
        if (assetsReady){
          clearInterval(wait);
          startGame();
        }
      }, 60);
    }
  }, {passive:true});
})();
</script>

<!-- ✅ 1) 외부 라이브러리는 단독 script로 로드 -->
<!-- ✅ 2) 그 다음에 커스텀 채팅 코드 -->


<!-- ✅ tmi.js 로더: jsDelivr → unpkg → local(tmi.min.js) 순서로 시도 -->
<script>
(function(){
  const sources = [
    "https://cdn.jsdelivr.net/npm/tmi.js@1.8.5/dist/tmi.min.js",
    "https://unpkg.com/tmi.js@1.8.5/dist/tmi.min.js",
    "tmi.min.js" // 같은 폴더에 tmi.min.js를 두면 최종 fallback
  ];

  function loadOne(i){
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = sources[i];
      s.async = true;
      s.crossOrigin = "anonymous";
      s.onload = () => resolve(sources[i]);
      s.onerror = () => reject(new Error("load failed: " + sources[i]));
      document.head.appendChild(s);
    });
  }

  (async () => {
    for (let i=0; i<sources.length; i++){
      try{
        const ok = await loadOne(i);
        console.log("[tmi-loader] loaded:", ok);
        return;
      }catch(e){
        console.warn("[tmi-loader]", e.message);
      }
    }
    console.error("[tmi-loader] all sources failed");
  })();
})();
</script>

<script>
  // ====== TWITCH CHAT (custom overlay) ======
  // ✅ tmi.js로 IRC 채팅을 직접 받아 렌더링합니다.
  // ✅ "읽기용(익명)"은 토큰/로그인 없이 가능 (tmi.js 공식 예제 방식)
  const TWITCH_CHANNEL = "lastkan1111"; // ✅ 채널명만 바꾸면 됩니다.

  function chatSys(msg){
    const bodyEl = document.getElementById('twitchChatBody');
    if (!bodyEl) return;
    const line = document.createElement('div');
    line.className = 'chatLine';
    line.style.opacity = "0.85";
    line.innerHTML = `<span class="chatName" style="color:rgba(255,255,255,0.75)">[system]</span> <span class="chatMsg">${msg}</span>`;
    bodyEl.appendChild(line);
    while (bodyEl.childNodes.length > 160) bodyEl.removeChild(bodyEl.firstChild);
    bodyEl.scrollTop = bodyEl.scrollHeight;
  }

  function initCustomTwitchChat(){
    const titleEl = document.getElementById('twitchChatTitle');
    const statusEl = document.getElementById('twitchChatStatus');
    const bodyEl = document.getElementById('twitchChatBody');

    if (titleEl) titleEl.textContent = `@${TWITCH_CHANNEL} chat`;

    // tmi.js 로드 체크
    let tries = 0;
    const waitForTmi = () => {
      if (window.tmi) return true;
      tries++;
      if (tries <= 50) { // 약 5초 (100ms * 50)
        if (statusEl) statusEl.textContent = "tmi.js 로딩중...";
        return false;
      }
      return false;
    };
    if (!window.tmi){
      const timer = setInterval(() => {
        if (waitForTmi()){
          clearInterval(timer);
          initCustomTwitchChat(); // 재호출
        } else if (tries > 50){
          clearInterval(timer);
          if (statusEl) statusEl.textContent = "tmi.js 로드 실패";
          chatSys("tmi.js가 로드되지 않았습니다. 광고차단/방화벽/회사망에서 CDN 차단일 수 있어요.");
          chatSys("해결: (1) 다른 CDN 허용 (2) 같은 폴더에 tmi.min.js 파일을 넣고 새로고침");
        }
      }, 100);
      return;
    }

    if (statusEl) statusEl.textContent = "연결중...";
    chatSys("채팅 연결 시도중...");

    // ✅ 익명(읽기) 연결: identity 없이 channels만 주면 됩니다. (tmi.js 공식 예제)
    const client = new tmi.Client({
      options: { debug: true },
      connection: { secure: true, reconnect: true },
      channels: [ TWITCH_CHANNEL ]
    });

    function addLine(displayName, color, message){
      const line = document.createElement('div');
      line.className = 'chatLine';

      const name = document.createElement('span');
      name.className = 'chatName';
      name.textContent = (displayName || "viewer") + ": ";
      if (color) name.style.color = color;

      const msg = document.createElement('span');
      msg.className = 'chatMsg';
      msg.textContent = message;

      line.appendChild(name);
      line.appendChild(msg);
      bodyEl.appendChild(line);

      while (bodyEl.childNodes.length > 160) bodyEl.removeChild(bodyEl.firstChild);
      bodyEl.scrollTop = bodyEl.scrollHeight;
    }

    client.on('connecting', (addr, port) => {
      if (statusEl) statusEl.textContent = "연결중...";
      chatSys(`서버 연결중 (${addr}:${port})`);
    });

    client.on('connected', (addr, port) => {
      if (statusEl) statusEl.textContent = "연결됨";
      chatSys(`연결됨 (${addr}:${port})`);
      chatSys("채팅이 조용하면(오프라인/채팅 없음) 테스트로 채널에 한 줄 입력해보세요.");
    });

    client.on('disconnected', (reason) => {
      if (statusEl) statusEl.textContent = "끊김";
      chatSys(`연결 끊김: ${reason || "unknown"}`);
    });

    client.on('join', (channel, username, self) => {
      if (self) chatSys(`채널 참가: ${channel}`);
    });

    client.on('notice', (channel, msgid, message) => {
      chatSys(`NOTICE(${msgid}): ${message}`);
    });

    client.on('message', (channel, tags, message, self) => {
      if (self) return;
      if (!message || !message.trim()) return;
      addLine(tags['display-name'], tags.color, message);
    });

    client.connect().catch((err) => {
      if (statusEl) statusEl.textContent = "연결 실패";
      chatSys("connect() 실패: " + (err?.message || String(err)));
      console.error(err);
    });
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initCustomTwitchChat);
  } else {
    initCustomTwitchChat();
  }
</script>


</body>
</html>
